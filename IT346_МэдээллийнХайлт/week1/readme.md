# Boolean retrieval | Булийн хайлт

## 1. Танилцуулга 

### Мэдээллийн хайлтын тодорхойлолт

* Мэдээллийн хайлт (IR) - Компьютеруудэд хадаглагдсан бүтэцгүй их хэмжээий цуглуулгаас (баримтуудын олонлог) хэрэглэгчийн мэдээллийн хэрэгцээг хангасан баримтыг олохыг хэлнэ.

### Бүтцийн өгөгдөл хүснэгт, өгөгдлийн сан 

| Ажилтан | Менежер | Цалин |
| :------ | ------- | -----:|
| Пүрэв | Цэнд | 5000 |
| Төмөр | Ханд | 6000 |
| Бат | Даш | 5000 |

Бүтцийн өгөгдөлтэй баримтууд XLS, SQL

### Бүтэцгүй өгөгдөл

* Текст баримт

Үүнд DOC, PDF, PPT, LaTex, HTML хуудас

Ном, зохиол, өгүүлэг, эссэ, шүлэг, яруу найраг, өгүүлэл, нийтлэл, лекц, тест, дипломын ажил, төсөл, төслийн тайлан, шүүмж, зөвөлгөө, санао гомдол, зар, суртчилгаа, пост, комент,

## 2. Булийн хайлт

* Google [W1, W2, .... Wn] гэсэн query-г W1 AND W2 AND ... AND Wn хөрвүүлж хайдаг

* Булийн хайлт - мэдээлэл хайлтын системийн хамгийн энгийн загвар

* Query нь булийн илэрхийлэл (AND, OR)

* Хайлтын систем нь булийн илэрхийллийг хангах бүх баримтуудыг буцаадаг

===============================================================================================================

* q = "туул" AND "гол" Туул ба гол үг агуулсан баримтуудыг хайна

* q = "туул" OR "гол", Туул эсхүл гол гэсэн үг агуулсан баримт хайх

* q = "туул" AND NOT "гол" гол агуулаагүй зөвхөн туул агуулсан баримт хайх

* Q = кекс AND жор AND NOT өндөг

===============================================================================================================

### Хамаарлын вектор

* Үг бүрт харгалзах 0 ба 1 - ийн дарааллыг вектор гэнэ
	
	110001, 110100, 110111, 010000...

* Q = Brutus AND Caesar AND NOT Calpurnia query-д харгалзах жүжиг ол

* query-н хариу олох:
	
	* Brutus, Caesar, NOT Calpurnia векторуудыг авна

	* 110100 110111 101111 (Үүнд NOT 01000 = 101111)

	* Үржүүлнэ 110100 AND 110111 AND 101111 = 100100

### Үг-баримтын индекс

* Дүрүүдийг үг, жүжгүүдийг баримт гэж нэрлэдэг.

* Матрицыг `үг-баримтын индекс` гэнэ

* Үгийн цуглуулгыг толь гэнэ

* Баримтуудыг дугааруудыг жагсаалт гэнэ

* Шинэ баримтыг индексэд нэмэхийг баримтыг `индекслэх` гэнэ

* Индексээс үг вектор ашиглан хайхыг `булийн хайлт` гэнэ

* Хайлтын үр дүн үг агуулсан баримтууд эсвэл үгийг агуулаагүй бол хоосоэн үр дүн гарна.

### Баримтын том хэмжээний цуглуулгх

* Тус бүр нь 1000 үгтэй N = 1 сая баримт байвал цуглуулга бүгд 10^9 үгтэй болно

* Компьютерт хадаглах бол үг бүрийг 6 байтаар авбал баримтын цуглуулга хэмжээ 6*10^9 = 6GB болно

* Хэрэв M = 500,000 ялгаатай үгтэй бол цуглуулга 0.1 - ээс бүрдсэн 500K x 1M хэмжээний матриц болно. Хагас их наяд

Иймээс хамаарлын матриц байгуулж чадахгүй

* M = 500,000 x 10^6 = 0.1- тэй хагас их наяд 0.1

* Харин мариц 1 Тэрбум 1 - тэйгээс илүү байж болохгүй

	- Матриц хэт том болно

* Яаж дүрслэх вэ

	- Зөвхөн  - 1 үүдээ хдаглах уу?
	- Эсвэл өөр арга? -> урвуу матриц буюу `урвуу индекс` ашигладаг


### Урюуу индекс

t үг бүрт t-г агуулсан бүх баримтын дугааруудыг үүсгэн хадаглахыг урвуу индекс гэнэ

Brutus -> 1, 2, 3, 11, 31, 45, 173, 174

Caesar -> 1, 2, 4, 5, 6, 16, 57, 132 ...

Calpurnia -> 2, 31, 54, 101

#### Урвуу индекс байгуулах дараалал

1. Токенд хуваах

Өгөгдсөн баримтаас үгийг ялгахыг токенд хуваах гэнэ

2. Нормалчлах

	1. Үсгийг жижиг болгох, цэгтэй таслал, богино зураас ... гэх мэт тэмдэгтүүдийг устгах,
	2. Үгийг ижил утгатай толины үгээр солих. U.S.A=USA
	3. Үгийн үндсийг олж толины үгээр солих=stemming
	4. Үг хувирсан хэлбэртэй бол толины хувираагүй хэлбэрээр солих

3. Эквивалент класс үүсгэх

	1. Баримт бүрийн хувьд үгүүдийг нормалчил
	2. Нормалчилсан үгээ түүж эх үгт харгалзсан хүснэгт байгуул

	Энэ хүснэгт эквивалент класс болно. 
	Эквивалент классын эхний багана толь болно

4. Индекслэх

	(толь, баримтын дугаар)-ын дараалал үүсгэхийг индекслэх гэнэ Үүнд term-толины үг
	docID – баримтын дугаар Үүнийг урвуу индекс гэнэ

### Хоёр жагсаалтын оголцолын алгоритм

```
Intersect(p1, p2)
	answer <- ()
	while p1 != nil, and p2 != nil
	do if docID(p1) = docID(p2)
		then Add(answer, docID(p1))
			p1 <- next(p1)
			p2 <- next(p2)
		else if docID(p1) < docID(p2)
			   then p1 <- next(p1)
			   then p2 <- next(p2)
	return answer
```

### Харьцуулах үйлдлийн тоог олох

* Энэ алгоритмд жагсаалт бүрийн эхэнд хоёр заагч байрлана.
* Зааж буй docID-ууд ижил бол answer-д нэмээд зэрэг дараагийн баримтыг заана
* Харин үгүй бол бага docID-ын дараагийнхийг заана
* X,y-нь жагсаалтуудын урт бол алгоритм O(x+y) харьцуулах үйлдэл хийнэ. O(8+4)=8
* 32>8 буюу шугаман хайлтаас хурдан бна

### OR үйлдэлтэй нийлмэл query

* (madding OR crowd) AND (ignoble OR strife)
* Query-н үг бүрийн баримтуудын дугааруудаар жагсаалт үүсгэнэ
* Жагсаалтуудаа нэгтгэж өсөхөөр эрэмбэлнэ
* Давтагдсан дугааруудыг устгана
* Үлдсэн жагсаалт нь хайлтын үр дүн болно

### Нийлмэл query-д зориулсан огтолцлын оновчлосон алгоритм

```
Intersect((t1,....,tn))
	terms <- SortByIncreasingFrquency((t1, ...., tn))
	result <- postings(first(terms))
	terms <- rest(terms)
	while terms != nil and result != nil
	do result <- intersect(result, postings(first(terms)))
		terms <- rest(terms)
	return result
```

### Хоёр урвуу индексийг нэгтгэх

* Индексүүдийг нэгтгэхдээ санах ойн хэмжээнд зохицуулан санах ой, диск хоёрыг ашиглан хийдэг (ойд индексээ байгуулаад, хэсгийг дискэнд хадгална. Тэгээд дахиад нэг индекс байгуулна. Дискэнд хадгалсан хэсгүүдээ нэгтгэнэ

